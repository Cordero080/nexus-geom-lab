# Priority 2.5: Modern React Patterns

**Total Time: 1 hour**  
**Goal: Understand the React patterns AI uses in your codebase**

This bridges the gap between "AI generated React code" and "I understand React patterns."

---

## Why This Priority is Critical for AI Development

**The Problem:** AI generates React code using modern patterns, but you don't understand:

- When to use `useRef` vs `useState`
- How event handling actually works
- Why some rendering is conditional
- How dynamic styling with variables works

**The Solution:** Learn the React patterns so you can:

- Modify AI-generated components confidently
- Debug when components don't behave correctly
- Make informed decisions about state management
- Understand when to re-render vs when to use refs

---

## Task 2.5.1: useRef vs useState Pattern (20 minutes)

### The DOM Manipulation Pattern

**Files to examine:**

- `src/HomePage/HomePage.jsx` (look for `useRef` and parallax code)

### Two Different Approaches

**Your app uses BOTH patterns strategically:**

1. **useState for React state** (triggers re-renders):

   ```javascript
   const [portalState, setPortalState] = useState(/* initial value */);
   ```

2. **useRef for DOM manipulation** (no re-renders):
   ```javascript
   const layer1Ref = useRef(null);
   // Later: layer1Ref.current.style.transform = '...';
   ```

### Key Questions to Answer

**In HomePage.jsx, find the parallax system:**

1. **Why useRef for parallax layers?**

   - Find `layer1Ref`, `layer2Ref`, etc.
   - See how they're used in mouse events
   - Understand why this doesn't use useState

2. **Why useState for portal colors?**
   - Find `portalState` and `setPortalState`
   - See how changing it triggers re-renders
   - Understand why this can't use useRef

### The Performance Insight

**useRef:** Direct DOM manipulation, no re-renders (fast)  
**useState:** Triggers component re-render (slower but reactive)

**Practice Exercise:**
Look at your parallax mouse handler - count how many elements get updated on every mouse move. Imagine if each one triggered a React re-render!

**‚úÖ Checkpoint:** You should understand why parallax uses refs but color changes use state.

---

## Task 2.5.2: Event Handling Patterns (15 minutes)

### React Event System

**Files to examine:**

- `src/HomePage/HomePage.jsx` (mouse event handlers)
- `src/main.jsx` (global click handler)

### Different Event Approaches

**Your app uses multiple event patterns:**

1. **React synthetic events** (in JSX):

   ```javascript
   <button onClick={handleClick}>
   ```

2. **Native DOM events** (in useEffect):

   ```javascript
   document.addEventListener("click", updateGlobalPortalColors);
   ```

3. **Cleanup patterns** (preventing memory leaks):
   ```javascript
   return () => document.removeEventListener("click", handler);
   ```

### Key Questions to Answer

1. **Global vs component events:**

   - Why is the portal color change in main.jsx (global)?
   - Why are parallax events in HomePage.jsx (component-specific)?

2. **Event cleanup:**
   - Find `useEffect` with cleanup functions
   - Understand why cleanup is necessary

**‚úÖ Checkpoint:** You should understand when to use global vs component events.

---

## Task 2.5.3: Conditional Rendering Patterns (15 minutes)

### Smart UI Updates

**Files to examine:**

- `src/App.jsx` (authentication-based rendering)
- Various components with conditional logic

### Common Patterns in Your App

1. **Authentication-based rendering:**

   ```javascript
   {
     isAuthenticated ? <GeomLab /> : <Navigate to="/login" />;
   }
   ```

2. **Feature-based rendering:**

   ```javascript
   {
     isAuthenticated && (
       <>
         <Link to="/scenes">SCENES</Link>
         <Link to="/showcase">SHOWCASE</Link>
       </>
     );
   }
   ```

3. **State-based rendering:**
   ```javascript
   {
     selectedAnimation && <ShowcaseViewer />;
   }
   ```

### Key Questions to Answer

**In App.jsx:**

1. **Why the authentication checks?**

   - Find the `isAuthenticated` variable
   - See how it controls what renders
   - Understand the user experience flow

2. **What's the difference between:**
   - `condition ? A : B` (ternary - always renders something)
   - `condition && A` (logical AND - renders A or nothing)

**‚úÖ Checkpoint:** You should understand how your app shows different content to different users.

---

## Task 2.5.4: Dynamic Styling Patterns (10 minutes)

### Reactive Styles

**Files to examine:**

- `src/HomePage/HomePage.jsx` (navbar inline styles)
- Any component with `style={{...}}`

### Pattern Analysis

**Your app uses dynamic styles for:**

1. **Portal state colors:**

   ```javascript
   style={{
     background: `rgba(0,0,0,0.85)`,
     boxShadow: `0 2px 16px 0 ${portalState.colors[2]}08`,
   }}
   ```

2. **Animation-based styles:**
   ```javascript
   style={{
     transform: `translateX(${offset}px)`,
     opacity: isVisible ? 1 : 0,
   }}
   ```

### Key Insights

**When to use inline styles:**

- ‚úÖ When values come from JavaScript variables
- ‚úÖ When styles need to change based on state
- ‚ùå When styles are static (use CSS classes instead)

**Template literal patterns:**

- Using `${}` to inject variables into CSS strings
- Combining static and dynamic values

**‚úÖ Checkpoint:** You should understand when your app chooses inline styles vs CSS classes.

---

## Why These Patterns Matter for AI Development

### **Before This Study:**

‚ùå "AI uses useRef and useState randomly"  
‚ùå "Event handlers are confusing and I don't know why there are different types"  
‚ùå "Conditional rendering seems inconsistent"  
‚ùå "Inline styles vs CSS classes seems arbitrary"

### **After This Study:**

‚úÖ "useRef for performance, useState for reactivity"  
‚úÖ "Global events for app-wide features, component events for local features"  
‚úÖ "Conditional rendering controls user experience flow"  
‚úÖ "Inline styles for dynamic values, CSS classes for static styles"

---

## Advanced Pattern Recognition

### Performance Optimization Patterns

**Look for these in your code:**

1. **Ref-based animations** (no re-renders)
2. **Event delegation** (fewer event listeners)
3. **Cleanup functions** (prevent memory leaks)
4. **Strategic re-rendering** (only when necessary)

### State Management Patterns

**Your app's state strategy:**

1. **Local state** for component-specific data
2. **Context** for app-wide data (auth, themes)
3. **Refs** for DOM manipulation
4. **Global events** for cross-component communication

---

## Success Criteria

After 1 hour, you should be able to:

1. **Explain when to use useRef vs useState** and find examples in your code
2. **Identify different event handling patterns** and understand their purposes
3. **Recognize conditional rendering patterns** and their UX implications
4. **Understand dynamic styling decisions** and when to use each approach

---

## Pattern Quick Reference

**useRef:** DOM manipulation, no re-renders  
**useState:** Reactive data, triggers re-renders  
**Global events:** App-wide features (portal colors)  
**Component events:** Local features (parallax)  
**Conditional rendering:** `condition && <Component />` or `condition ? A : B`  
**Dynamic styles:** `style={{property: variable}}`

---

## Next Step

üöÄ **Continue to Priority 3: 3D Rendering**

Now you understand the React patterns that make your app interactive and performant. You can confidently read and modify AI-generated React code because you understand the underlying patterns and their purposes.

**Key insight:** Modern React is about choosing the right pattern for each situation, not following rigid rules.
